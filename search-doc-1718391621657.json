[{"title":"Development Environment","type":0,"sectionRef":"#","url":"/docs/developer_guide/development_environment","content":"","keywords":"","version":"Next"},{"title":"Package Manager​","type":1,"pageTitle":"Development Environment","url":"/docs/developer_guide/development_environment#package-manager","content":" Before developing Momentum, it is necessary to install various dependencies. This process can be platform-dependent and tedious. To simplify this, Momentum utilizes Pixi.  Pixi facilitates building Momentum in a virtual environment across different platforms (Windows, macOS ARM, Linux) using consistent command lines.  For those interested, you can examine the `pixi.toml`` file to see how dependencies are specified and to explore the available Pixi tasks for Momentum.  info If you choose not to use Pixi, you will need to manually install all dependencies using platform-specific package managers. These typically install dependencies into the system directory. Ensure you have the appropriate package managers installed for your OS: Homebrew for macOS, Vcpkg for Windows, and apt for Ubuntu/Debian. After installation, refer to pixi.toml for guidance on what and how to install.  ","version":"Next","tagName":"h2"},{"title":"Running Predefined Tasks​","type":1,"pageTitle":"Development Environment","url":"/docs/developer_guide/development_environment#running-predefined-tasks","content":" To build and manage the project using Pixi, follow these steps:  Build the project with the command: pixi run build Run the tests using the command: pixi run test   To view all available command lines, run pixi task list.  ","version":"Next","tagName":"h2"},{"title":"Running Custom Commands in Shell​","type":1,"pageTitle":"Development Environment","url":"/docs/developer_guide/development_environment#running-custom-commands-in-shell","content":" To execute additional commands in the virtual environment, such as using CMake directly or running an executable, activate the virtual environment with:  pixi shell   To exit the virtual environment, simply run:  exit   ","version":"Next","tagName":"h2"},{"title":"Developing with Microsoft Visual Studio (Windows Only)​","type":1,"pageTitle":"Development Environment","url":"/docs/developer_guide/development_environment#developing-with-microsoft-visual-studio-windows-only","content":" To open the project in Visual Studio 2022, use the command:  pixi run open-vs  ","version":"Next","tagName":"h3"},{"title":"Style Guide","type":0,"sectionRef":"#","url":"/docs/developer_guide/style_guide","content":"","keywords":"","version":"Next"},{"title":"Error Handling​","type":1,"pageTitle":"Style Guide","url":"/docs/developer_guide/style_guide#error-handling","content":" Momentum uses exceptions for handling unrecoverable errors, which is essential for a lower-level library like this. Throwing exceptions allows error detection mechanisms to have visibility into these errors and prevents silent failures, which may lead to more severe bugs. By choosing exceptions as the primary method for error handling in Momentum, we ensure that unrecoverable errors are easily detectable, and the Momentum library remains user-friendly for developers interacting with the application layer.  Using exceptions is especially crucial when considering the application layer as the user of the Momentum library. For layers closer to the services, everything should be surrounded by try-catch blocks to prevent server crashes while still providing valuable error information. Python programmers, who often interact with the application layer, typically expect exceptions, making it a more reasonable approach for error handling in Momentum.  One important caution is to avoid using exceptions for flow control; common errors, such as &quot;L2 norm is too high,&quot; should not result in exceptions being thrown.  ","version":"Next","tagName":"h2"},{"title":"Alternative Approaches​","type":1,"pageTitle":"Style Guide","url":"/docs/developer_guide/style_guide#alternative-approaches","content":" std::options​  While optional types can be acceptable in some cases, they can lead to the loss of error information, which is not ideal for the application layer. We use optional types for inputs that can be missing for a few frames due to reasons such as lost tracking, but in these cases, the specific reason is not critical.  folly::Expected​  Folly::Expected acts like an optional type but allows for an error type to be specified (see documentation here). This can be useful in some APIs, particularly if error codes need to be serialized or for other similar purposes. In general, folly::Expected is preferred over std::optional.  ","version":"Next","tagName":"h3"},{"title":"Array Access​","type":1,"pageTitle":"Style Guide","url":"/docs/developer_guide/style_guide#array-access","content":" When accessing elements within arrays, the Momentum codebase employs two methods: the .at() method and the [] operator. The choice between these two methods should be made based on the considerations of performance, safety, and the intended audience of the code:  It is recommended to use the [] operator for code that is self-contained and developed by the Momentum team, especially for low-level and performance-critical code. The [] operator does not perform bounds checking, thus offering better performance. Conversely, the .at() method should be considered for areas of code that might be accessed by the user as it performs bounds checking to prevent out-of-range errors, enhancing the safety of the code.  ","version":"Next","tagName":"h3"},{"title":"Design Decisions​","type":1,"pageTitle":"Style Guide","url":"/docs/developer_guide/style_guide#design-decisions","content":" ","version":"Next","tagName":"h2"},{"title":"Prefer gsl::span over typed container like `std::vector`` as function argument​","type":1,"pageTitle":"Style Guide","url":"/docs/developer_guide/style_guide#prefer-gslspan-over-typed-container-like-stdvector-as-function-argument","content":" Using std::vector&lt;T&gt; as a function argument requires the call site to create an std::vector&lt;T&gt; instance even when the data is already stored in a compatible memory layout, such as contiguous memory. By switching to gsl::span&lt;T&gt;, call sites can avoid creating an additional std::vector&lt;T&gt; object and benefit from improved performance by not requiring an unnecessary data copy. ","version":"Next","tagName":"h3"},{"title":"Viewers","type":0,"sectionRef":"#","url":"/docs/examples/viewers","content":"","keywords":"","version":"Next"},{"title":"GLB Viewer​","type":1,"pageTitle":"Viewers","url":"/docs/examples/viewers#glb-viewer","content":" To run the GLB viewer, use the following command:  pixi run glb-viewer --input &lt;my_file.glb&gt;     Source Code  ","version":"Next","tagName":"h2"},{"title":"FBX Viewer​","type":1,"pageTitle":"Viewers","url":"/docs/examples/viewers#fbx-viewer","content":" To run the FBX viewer, use the following command:  pixi run fbx-viewer --input &lt;my_file.fbx&gt;   Source Code  ","version":"Next","tagName":"h2"},{"title":"C3D Viewer​","type":1,"pageTitle":"Viewers","url":"/docs/examples/viewers#c3d-viewer","content":" To run the C3D viewer, use the following command:  pixi run c3d-viewer --input &lt;my_file.c3d&gt;   Source Code ","version":"Next","tagName":"h2"},{"title":"Process Markers","type":0,"sectionRef":"#","url":"/docs/examples/process_markers","content":"","keywords":"","version":"Next"},{"title":"Optical Marker based Body Tracking​","type":1,"pageTitle":"Process Markers","url":"/docs/examples/process_markers#optical-marker-based-body-tracking","content":" This project provides a set of core functions to solve for body motions based on optical marker inputs. It supports all PC OSes (untested on mobile). The marker_tracker lib contains core functionalities for downstream applications to build on. Demo applications are provided to show how they can be used to build your data processing pipeline. process_markers_app solves for body motion given an input marker sequence, with or without an existing calibrated skeleton. refine_motion runs smoothing as a post process to fill in missing data from input. They can be used to batch process mocap data in a python script.  info The Momentum ecosystem implicitly operates in centimeter. If you are working with c3d files, we will do the unit conversion based on the stored unit on file. However, if you are using our API with your own data, make sure to convert them into cm. We also assume a Y-up coordinate system, which is not the industry convention (i.e., Z-up).  ","version":"Next","tagName":"h2"},{"title":"Example use cases​","type":1,"pageTitle":"Process Markers","url":"/docs/examples/process_markers#example-use-cases","content":" Get the full list of options for each application with -h or --help argument. 02_01.c3d is an example input file used by the default config files. Note that a config file can be used together with command line options. The command line overwrites values in the config file.  ","version":"Next","tagName":"h2"},{"title":"Track a marker sequence without a calibrated model.​","type":1,"pageTitle":"Process Markers","url":"/docs/examples/process_markers#track-a-marker-sequence-without-a-calibrated-model","content":" The first step in tracking a marker file is to calibrate the subject's proportions and the markers' placement. It requires a .locators file that defines a template of marker layout on the body. We have a template file with common layouts from Vicon and OptiTrack. There is usually a Range-of-Motion (ROM) sequence captured for this calibration purpose.  Use a config file:    pixi run process-markers -c process_markers_calib.config   Setting the calibrate option to true will first calibrate the skeleton and the marker layout, then use the calibrated model for motion tracking.    ","version":"Next","tagName":"h2"},{"title":"Track a marker sequence with a calibrated model.​","type":1,"pageTitle":"Process Markers","url":"/docs/examples/process_markers#track-a-marker-sequence-with-a-calibrated-model","content":" The tracking result from the above calibration step contains the calibrated model, and it can then be used to track other motion data from the same subject, without running the calibration step again. We currently only support saving/loading calibrated models in .glb format.  Use a config file:    pixi run process_markers -c process_markers_tracking.config   Use cli arguments:    pixi run process_markers -i input.c3d -o tracked.glb --model calibrated_model.glb --calibrate false  ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/user_guide/getting_started","content":"","keywords":"","version":"Next"},{"title":"Supported Environments​","type":1,"pageTitle":"Getting Started","url":"/docs/user_guide/getting_started#supported-environments","content":" OS: Windows, Linux, macOS  ","version":"Next","tagName":"h2"},{"title":"Prerequisite​","type":1,"pageTitle":"Getting Started","url":"/docs/user_guide/getting_started#prerequisite","content":" Complete the following steps only once:  Install Pixi by following the instructions on https://prefix.dev/  ","version":"Next","tagName":"h2"},{"title":"Install Momentum​","type":1,"pageTitle":"Getting Started","url":"/docs/user_guide/getting_started#install-momentum","content":" Clone the repository and navigate to the root directory:  clone https://github.com/facebookincubator/momentum cd momentum   Build and install Momentum in a virtual environment using Pixi:  pixi run cmake --build build --target install --parallel   ","version":"Next","tagName":"h2"},{"title":"Creating Your First Application​","type":1,"pageTitle":"Getting Started","url":"/docs/user_guide/getting_started#creating-your-first-application","content":" ","version":"Next","tagName":"h2"},{"title":"Writing Source Code​","type":1,"pageTitle":"Getting Started","url":"/docs/user_guide/getting_started#writing-source-code","content":" Now, let's define a simple Momentum application. Create a new file named main.cpp with the following content:  #include &lt;momentum/math/mesh.h&gt; using namespace momentum; int main() { auto mesh = Mesh(); mesh.updateNormals(); return EXIT_SUCCESS; }   ","version":"Next","tagName":"h3"},{"title":"Writing CMake Script​","type":1,"pageTitle":"Getting Started","url":"/docs/user_guide/getting_started#writing-cmake-script","content":" Create a CMakeLists.txt file in the same directory as main.cpp.  To add momentum to your CMake project, first find the momentum package using thefind_package function and then add the appropriate momentum::&lt;target&gt; as a dependency to your library or executable. For example, if you want to use the character functionality from momentum, you would add momentum::character as a dependency:  cmake_minimum_required(VERSION 3.16.3) project(momentum) find_package(momentum CONFIG REQUIRED) add_executable(hello_world main.cpp) target_link_libraries(hello_world PRIVATE momentum::math)   Refer to the example project located at momentum/examples/hello_world/ for the complete source code.  ","version":"Next","tagName":"h3"},{"title":"Building using CMake​","type":1,"pageTitle":"Getting Started","url":"/docs/user_guide/getting_started#building-using-cmake","content":" To configure the application, run:  # Linux and macOS pixi run cmake -S momentum/examples/hello_world -B momentum/examples/hello_world/build -DCMAKE_BUILD_TYPE=Release # Windows pixi run cmake -S momentum/examples/hello_world -B momentum/examples/hello_world/build   To build the application, run:  # Linux and macOS pixi run cmake --build momentum/examples/hello_world/build # Windows pixi run cmake --build momentum/examples/hello_world/build --config Release   ","version":"Next","tagName":"h3"},{"title":"Run the Application​","type":1,"pageTitle":"Getting Started","url":"/docs/user_guide/getting_started#run-the-application","content":" Execute the application with:  ./momentum/examples/hello_world/build/hello_world  ","version":"Next","tagName":"h3"}]